Index: compat-wireless-2011-12-01/drivers/net/wireless/ath/ath9k/debug.c
===================================================================
--- compat-wireless-2011-12-01.orig/drivers/net/wireless/ath/ath9k/debug.c	2012-07-31 17:01:41.814428324 +0200
+++ compat-wireless-2011-12-01/drivers/net/wireless/ath/ath9k/debug.c	2012-07-31 17:01:42.034478211 +0200
@@ -20,12 +20,24 @@
 #include <asm/unaligned.h>
 
 #include "ath9k.h"
+#include "../ath.h"
+#include "../reg.h"
 
 #define REG_WRITE_D(_ah, _reg, _val) \
 	ath9k_hw_common(_ah)->ops->write((_ah), (_val), (_reg))
 #define REG_READ_D(_ah, _reg) \
 	ath9k_hw_common(_ah)->ops->read((_ah), (_reg))
 
+#if 0
+#define ENABLE_REGWRITE_BUFFER(_ah)			\
+	if (ath9k_hw_common(_ah)->ops->enable_write_buffer)		\
+		ath9k_hw_common(_ah)->ops->enable_write_buffer((_ah));
+
+#define REGWRITE_BUFFER_FLUSH(_ah)			\
+	if (ath9k_hw_common(_ah)->ops->write_flush)			\
+		ath9k_hw_common(_ah)->ops->write_flush((_ah));
+#endif
+
 static int ath9k_debugfs_open(struct inode *inode, struct file *file)
 {
 	file->private_data = inode->i_private;
@@ -1724,6 +1736,197 @@
 };
 
 
+static ssize_t read_file_keyidx(struct file *file, char __user *user_buf,
+                                size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "0x%08x\n", sc->debug.keyidx);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_keyidx(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	//printk(KERN_INFO "p: %pR\n", *sc);
+
+	unsigned long keyidx;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (strict_strtoul(buf, 0, &keyidx))
+		return -EINVAL;
+
+	sc->debug.keyidx = keyidx;
+	printk(KERN_INFO "keyidx: %d\n", sc->debug.keyidx);
+	//sc->debug.keyidx = 0x7;
+	//printk(KERN_INFO "keyidx: %d\n", sc->debug.keyidx);
+	return count;
+}
+
+static const struct file_operations fops_keyidx = {
+	.read = read_file_keyidx,
+	.write = write_file_keyidx,
+	.open = ath9k_debugfs_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t read_file_keyval(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+
+	printk(KERN_INFO "No! Definitely not...\n");
+	//printk(KERN_INFO "p: %pR\n", *sc);
+#if 0
+	struct ath_hw *ah = sc->sc_ah;
+	char buf[32];
+	unsigned int len;
+	u32 keyval;
+
+	ath9k_ps_wakeup(sc);
+	keyval = REG_READ_D(ah, sc->debug.keyidx);
+	ath9k_ps_restore(sc);
+	len = sprintf(buf, "0x%08x\n", keyval);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+#endif
+	return 0;
+}
+
+static ssize_t write_file_keyval(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+
+	char buf[64];
+	ssize_t len;
+
+	u32 key0, key1, key2, key3, key4;
+	u32 keyType;
+	u32 keyidx;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+	printk(KERN_INFO "len: %d\n", len);
+	buf[32] = '\0';
+
+	if (strict_strtoul(buf+24, 16, &key4))
+		return -EINVAL;
+	buf[32-8] = '\0';
+	if (strict_strtoul(buf+20, 16, &key3))
+		return -EINVAL;
+	buf[32-12] = '\0';
+	if (strict_strtoul(buf+12, 16, &key2))
+		return -EINVAL;
+	buf[32-20] = '\0';
+	if (strict_strtoul(buf+8, 16, &key1))
+		return -EINVAL;
+	buf[32-24] = '\0';
+	if (strict_strtoul(buf, 16, &key0))
+		return -EINVAL;
+
+	keyType = AR_KEYTABLE_TYPE_CCM;
+	keyidx = sc->debug.keyidx;
+
+	printk(KERN_INFO "Added key at idx: %d val: %08x%04x%08x%04x%08x\n", keyidx, key0, key1, key2, key3, key4);
+
+	key0 = ntohl(key0);
+	key1 = ntohs(key1);
+	key2 = ntohl(key2);
+	key3 = ntohs(key3);
+	key4 = ntohl(key4);
+	
+	ENABLE_REGWRITE_BUFFER(ah);
+
+	/* Write key[47:0] */
+	REG_WRITE_D(ah, AR_KEYTABLE_KEY0(keyidx), key0);
+	REG_WRITE_D(ah, AR_KEYTABLE_KEY1(keyidx), key1);
+
+	/* Write key[95:48] */
+	REG_WRITE_D(ah, AR_KEYTABLE_KEY2(keyidx), key2);
+	REG_WRITE_D(ah, AR_KEYTABLE_KEY3(keyidx), key3);
+
+	/* Write key[127:96] and key type */
+	REG_WRITE_D(ah, AR_KEYTABLE_KEY4(keyidx), key4);
+	REG_WRITE_D(ah, AR_KEYTABLE_TYPE(keyidx), keyType);
+
+	REGWRITE_BUFFER_FLUSH(ah);
+
+	return count;
+}
+
+static const struct file_operations fops_keyval = {
+	.read = read_file_keyval,
+	.write = write_file_keyval,
+	.open = ath9k_debugfs_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+static ssize_t write_file_keymac(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+
+	char buf[32];
+	ssize_t len;
+
+	u8 mac[6];
+	u32 keyidx;
+
+	u32 macHi, macLo;
+	u32 unicast_flag = AR_KEYTABLE_VALID;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+	buf[len] = '\0';
+
+	sscanf(buf, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &mac[0], &mac[1],
+	     &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	keyidx = sc->debug.keyidx;
+
+	macLo = get_unaligned_le32(mac);
+	macHi = get_unaligned_le16(mac + 4);
+
+	macLo >>= 1;
+	macLo |= (macHi & 1) << 31;
+	macHi >>= 1;
+
+	printk(KERN_INFO "Added mac at idx: %d val: %pM\n", keyidx, mac);
+
+	ENABLE_REGWRITE_BUFFER(ah);
+
+	REG_WRITE_D(ah, AR_KEYTABLE_MAC0(keyidx), macLo);
+	REG_WRITE_D(ah, AR_KEYTABLE_MAC1(keyidx), macHi | unicast_flag);
+
+	REGWRITE_BUFFER_FLUSH(ah);
+
+	return count;
+}
+
+static const struct file_operations fops_keymac = {
+	/*.read = read_file_keymac,*/
+	.write = write_file_keymac,
+	.open = ath9k_debugfs_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+
 int ath9k_init_debug(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
@@ -1797,7 +2000,17 @@
 	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
 			    sc, &fops_chanbw);
 
+	debugfs_create_file("keyidx", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_keyidx);
+
+	debugfs_create_file("keyval", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_keyval);
+
+	debugfs_create_file("keymac", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_keymac);
+
 	sc->debug.regidx = 0;
+	sc->debug.keyidx = 0;
 	memset(&sc->debug.bb_mac_samp, 0, sizeof(sc->debug.bb_mac_samp));
 	sc->debug.sampidx = 0;
 	sc->debug.tsidx = 0;
Index: compat-wireless-2011-12-01/drivers/net/wireless/ath/ath9k/debug.h
===================================================================
--- compat-wireless-2011-12-01.orig/drivers/net/wireless/ath/ath9k/debug.h	2012-07-31 17:06:55.094877981 +0200
+++ compat-wireless-2011-12-01/drivers/net/wireless/ath/ath9k/debug.h	2012-07-31 17:07:04.735210253 +0200
@@ -231,6 +231,7 @@
 	u8 sampidx;
 	u8 tsidx;
 	u8 rsidx;
+	u32 keyidx;
 };
 
 int ath9k_init_debug(struct ath_hw *ah);
